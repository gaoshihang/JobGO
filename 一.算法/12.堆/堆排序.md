时间复杂度为O(n2)的算法有冒泡排序、插入排序、选择排序；  
时间复杂度为O(nlogn)的算法有归并排序和快速排序。  
  
堆排序是借助堆这种数据结构实现的排序算法，其时间复杂度非常稳定，为O(nlogn)，且它是一个原地排序算法。  
  
**堆排序分为两个步骤：建堆和排序**。  
  
### 1.建堆
我们首先将数组原地建成一个堆。所谓“原地”就是，不借助另一个数组，就在原数组上操作。其有两种思路：  
第一种是借助我们前面讲的，在堆中插入一个元素的思路。尽管数组中包含n个数据，但是我们可以假设，起初堆中只包含一个数据，就是下标为1的数据。
然后，我们调用前面讲的插入操作，将下标从2到n的数据依次插入到堆中。这样我们就将包含n个数据的数组，组织成了堆。  
第二种实现思路，跟第一种截然相反，也是我这里要详细讲的。第一种建堆思路的处理过程是从前往后处理数组数据，并且每个数据插入堆中时，都是从下往上
堆化。而第二种实现思路，是从后往前处理数组，并且每个数据都是从上往下堆化。  

第二种思路代码如下：  
```
private static void buildHeap(int[] a, int n){
  for(int i = n/2; i >= 1;i--){
    heapify(a, n, i);
  }
}

private static void heapify(int[] a, int n, int i){
  while(true){
    int maxPos = i;
    if(i*2 <= n && a[i] < a[i*2]) maxPos = i*2;
    if(i*2 + 1 <= n && a[maxPos] < a[i*2+1]) maxPos = i*2+1;
    if(maxPos == i) break;
    swap(a, i, maxPos);
    i = maxPos;
  }
}
```

堆排序的建堆过程时间复杂度是O(n)。  

### 2.排序
建堆结束之后，数组中的数据已经是按照大顶堆的特性来组织的。数组中的第一个元素就是堆顶，也就是最大的元素。我们把它跟最后一个元素交换，那最大元
素就放到了下标为n的位置。  
这个过程有点类似上面讲的“删除堆顶元素”的操作，当堆顶元素移除之后，我们把下标为n的元素放到堆顶，然后再通过堆化的方法，将剩下的n-1个元素重新
构建成堆。堆化完成之后，我们再取堆顶的元素，放到下标是n-1的位置，一直重复这个过程，直到最后堆中只剩下标为1的一个元素，排序工作就完成了。  
```
public static void sort(int[] a, int n){
  buildHeap(a, n);
  int k = n;
  while(k > 1){
    swap(a, 1, k);
    k--;
    heapify(a, k, 1);
  }
}
```
排序过程的复杂度是O(nlogn)。  
堆排序不是稳定的排序算法。  














