### 一.动态规划的三大步骤
动态规划无非就是利用历史记录，来避免重复计算。而这些历史记录通常需要我们用一些变量来保存，一般是用一维数组和二维数组来保存。  
以下是动态规划的三个步骤：  
**步骤一**：定义数组元素的含义。比如dp[i]代表什么？  
**步骤二**：找出数组元素之间的关系式。比如dp[n] = dp[n-1] + dp[n-2]。可以利用历史记录推出新的元素值。  
**步骤三**：找出初始值。比如dp[1]和dp[2]等于多少。  

### 二.案例讲解
#### 1.简单的一维DP
**问题描述**：  
一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。  
##### （1）定义数组元素的含义
定义dp[i]的含义为：跳上i级的台阶总共有dp[i]中跳法。  
##### （2）找出数组间的关系式
动态规划就是把问题分成小的子问题，由小的子问题推导出大的问题。那么dp[n] 一定会和 dp[n-1], dp[n-2]….存在某种关系的。  
**怎么找，是动态规划最难的问题**。  
对于这道题，由于情况可以选择跳一级，也可以选择跳两级，所以青蛙到达第 n 级的台阶有两种方式：  
一种是从第 n-1 级跳上来；  
一种是从第 n-2 级跳上来。  
由于我们是要算所有可能的跳法的，所以有 dp[n] = dp[n-1] + dp[n-2]。  
##### （3）找出初始条件
dp[1] = 1;  
dp[2] = 2;  

代码如下：  
```
    public int climbStairs(int n) {
        if(n < 1) return 0;
        if(n == 1) return 1;
        if(n == 2) return 2;

        int[] dp = new int[n+1];
        dp[1] = 1;
        dp[2] = 2;
        for(int i = 3; i < n+1;i++){
            dp[i] = dp[i-1] + dp[i-2];
        }

        return dp[n];
    }
```

#### 2.二维数组的dp
**问题描述**：  
一个机器人位于一个 m x n 网格的左上角。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角。问总共有多少条不同的路径？  
##### （1）定义数组元素含义
当机器人从左上角走到(i, j) 这个位置时，一共有 dp[i][j] 种路径。那么，dp[m-1][n-1] 就是我们要的答案了。  
##### （2）找出关系式
机器人要怎么样才能到达 (i, j) 这个位置？由于机器人可以向下走或者向右走，所以有两种方式到达：  
一种是从 (i-1, j) 这个位置走一步到达；  
一种是从(i, j - 1) 这个位置走一步到达。  
因为是计算所有可能的步骤，所以是把所有可能走的路径都加起来，所以关系式是 dp[i][j] = dp[i-1][j] + dp[i][j-1]。  
##### （3）找出初始值
当 dp[i][j] 中，如果 i 或者 j 有一个为 0，那么还能使用关系式吗？答是不能的，因为这个时候把 i - 1 或者 j - 1，就变成负数了，数组就会出问题了，所以我们的初始值是计算出所有的 dp[0][0….n-1] 和所有的 dp[0….m-1][0]。这个还是非常容易计算的，相当于计算机图中的最上面一行和左边一列。因此初始值如下：  
dp[0] [0….n-1] = 1; // 相当于最上面一行，机器人只能一直往左走；  
dp[0…m-1] [0] = 1; // 相当于最左面一列，机器人只能一直往下走。  

代码如下：  
```
public static int uniquePaths(int m, int n){
  int[][] dp = new int[m][n];
  
  for(int i = 0; i < m;i++){
    dp[i][0] = 1;
  }
  
  for(int j = 0; j < n; j++){
    dp[0][j] = 1;
  }
  
  for(int i = 1; i < m; i++){
    for(int j = 1; j < n;j++){
      dp[i][j] = dp[i-1][j] + dp[i][j-1];
    }
  }
  
  return dp[m-1][n-1];
}
```

#### 3.难一些的二维数组dp
**问题描述**  
给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。  
##### （1）定义数组元素含义
定义dp[i][j]的含义为：当机器人从左上角走到(i, j) 这个位置时，最小的路径和是 dp[i][j]。  
##### （2）找出数组元素间关系式
dp[i][j] = arr[i][j] + min(dp[i-1][j] + dp[i][j-1]) //arr[i][j]表示网格中的值  
##### （3）找出初始值
所以我们的初始值是计算出所有的 dp[0][0….n-1] 和所有的 dp[0….m-1][0]。这个还是非常容易计算的，相当于计算机图中的最上面一行和左边一列。因此初始值如下：  
dp[0][j] = arr[0][j] + dp[0][j-1]; // 相当于最上面一行，机器人只能一直往左走;  
dp[i][0] = arr[i][0] + dp[i-1][0];  // 相当于最左面一列，机器人只能一直往下走.  

代码如下：  
```
    public static int minPathSum(int[][] grid){
        int m = grid.length;
        int n = grid[0].length;

        int[][] dp = new int[m][n];
        dp[0][0] = grid[0][0];
        for(int i = 1; i < m; i++){
            dp[i][0] = dp[i-1][0] + grid[i][0];
        }

        for(int j = 1; j < n; j++){
            dp[0][j] = dp[0][j-1] + grid[0][j];
        }

        for(int i = 1; i < m;i++){
            for(int j = 1; j < n;j++){
                dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + grid[i][j];
            }
        }

        return dp[m-1][n-1];
    }
```  

#### 4.编辑距离
**问题描述**  
给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数。  
你可以对一个单词进行如下三种操作：  
插入一个字符  
删除一个字符  
替换一个字符  

```
示例 1:
输入: word1 = "horse", word2 = "ros"
输出: 3
解释: 
horse -> rorse (将 'h' 替换为 'r')
rorse -> rose (删除 'r')
rose -> ros (删除 'e')
```  

90% 的字符串问题都可以用动态规划解决，并且90%是采用二维数组。  
##### （1）定义数组元素的含义
定义 dp[i][j]的含义为：当字符串 word1 的长度为 i，字符串 word2 的长度为 j 时，将 word1 转化为 word2 所使用的最少操作次数为 dp[i][j]。  
##### （2）找出关系数组元素间的关系式
不管多难找，大部分情况下，dp[i][j] 和 dp[i-1][j]、dp[i][j-1]、dp[i-1][j-1] 肯定存在某种关系。  
因为我们的目标就是，从规模小的，通过一些操作，推导出规模大的。  
由于我们是要让操作的次数最小，所以我们要寻找最佳操作。那么有如下关系式：  
一、如果我们 word1[i] 与 word2 [j] 相等，这个时候不需要进行任何操作，显然有 dp[i][j] = dp[i-1][j-1]。（别忘了 dp[i] [j] 的含义哈）。  
二、如果我们 word1[i] 与 word2 [j] 不相等，这个时候我们就必须进行调整，而调整的操作有 3 种，我们要选择一种。三种操作对应的关系试如下（注意字符串与字符的区别）：  
（1）、如果把字符 word1[i] 替换成与 word2[j] 相等，则有 dp[i][j] = dp[i-1][j-1] + 1;  
（2）、如果在字符串 word1末尾插入一个与 word2[j] 相等的字符，则有 dp[i][j] = dp[i][j-1] + 1;  
（3）、如果把字符 word1[i] 删除，则有 dp[i][j] = dp[i-1][j] + 1;  
那么我们应该选择一种操作，使得 dp[i] [j] 的值最小，显然有  
dp[i] [j] = min(dp[i-1] [j-1]，dp[i] [j-1]，dp[[i-1] [j]]) + 1;  
##### （3）找出初始值
我们的初始值是计算出所有的 dp[0][0….n] 和所有的 dp[0….m][0]。这个还是非常容易计算的，因为当有一个字符串的长度为 0 时，转化为另外一个字符串，那就只能一直进行插入或者删除操作了。  
```
    public static int minDistance(String word1, String word2) {
        int n1 = word1.length();
        int n2 = word2.length();
        int[][] dp = new int[n1 + 1][n2 + 1];
        // dp[0][0...n2]的初始值
        for (int j = 1; j <= n2; j++)
            dp[0][j] = dp[0][j - 1] + 1;
        // dp[0...n1][0] 的初始值
        for (int i = 1; i <= n1; i++) dp[i][0] = dp[i - 1][0] + 1;
        // 通过公式推出 dp[n1][n2]
        for (int i = 1; i <= n1; i++) {
            for (int j = 1; j <= n2; j++) {
                // 如果 word1[i] 与 word2[j] 相等。第 i 个字符对应下标是 i-1
                if (word1.charAt(i - 1) == word2.charAt(j - 1)){
                    dp[i][j] = dp[i - 1][j - 1];
                }else {
                    dp[i][j] = Math.min(Math.min(dp[i - 1][j - 1], dp[i][j - 1]), dp[i - 1][j]) + 1;
                }
            }
        }
        return dp[n1][n2];
    }
```  























