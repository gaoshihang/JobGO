**CPU、内存和I/O设备的速度差异是并发编程背后的核心矛盾**。为了合理利用CPU的高性能，平衡三者的速度差异，计算机做出了以下贡献：  
（1）CPU增加了缓存，以均衡与内存的速度差异；  
（2）操作系统增加了进程、线程，分时复用CPU，进而均衡CPU与I/O设备的速度差异；  
（3）编译程序优化指令执行次序，使得缓存能够得到更加合理地利用。  

**以上三条就是并发程序很多诡异问题的根源**。  

### 一.源头一：缓存导致的可见性问题
一个线程对共享变量的修改，另一个线程立即看到，我们称为**可见性**。  
在多核时代，每颗CPU都有自己的缓存，这是CPU缓存与内存的数据一致性就不容易解决了，多个线程在不同的CPU上执行，这些线程操作的是不同的CPU缓存，这时不同线程之间就不具备可见性了。  

### 二.源头二：线程切换带来的原子性问题
由于IO太慢，早期的操作系统发明了多进程。其允许某个进程执行一小段时间，例如50毫秒，过了这个时间后操作系统会重新选择一个进程来执行（称为“任务切换”），这个50毫秒称为**时间片**。  
在一个时间片内，如果一个进程进行一个IO操作，例如读个文件，这时候进程会把自己标记为“休眠状态”并让出CPU使用权，待文件读进内存，操作系统会把这个休眠进程唤醒，有机会重新获得CPU使用权。  
早期的操作系统基于进程来调度CPU，**不同进程间是不共享内存空间的，所以进程要做任务切换就要切换内存映射地址，而一个进程创建的所有线程，都是共享一个内存空间的，所以线程做任务切换的成本很低**。  

任务切换是BUG的源头之一。任务切换的时机大多是在时间片结束时，现在的高级编程语言中的一条语句往往需要多条CPU指令完成，例如count += 1，至少需要三条CPU指令：  
（1）首先，把变量count从内存加载到CPU寄存器；  
（2）将count+1；  
（3）将结果写回内存（或缓存）。  
**任务切换时，可能发生在任何一条CPU指令执行完，而不是高级语言的一条语句**。如下图所示：  
![线程切换](https://upload-images.jianshu.io/upload_images/2818100-f8e067e3d65db094.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)  
**我们把任何**












