### 一.安全性问题
理论上线程安全的程序，就要避免出现原子性问题、可见性问题和有序性问题。但并不是所有的代码都要检查这三个问题，只有一种情况需要：**存在共享数据且该
数据会发生变化，通俗地讲就是有多个线程会同时读写同一数据**。  
多个线程同时访问同一数据，且至少有一个线程会写这个数据的时候，如果不采取防护措施，就会导致并发bug，这叫做**数据竞争**。  
**竞态条件**：指的是程序的执行结果依赖线程执行的顺序。可以按照下面这样理解竞态条件，在并发场景中，程序的执行依赖于某个状态变量，类似下面这样：  
```
if(状态变量 满足 执行条件){
  执行操作
}
```
某个线程发现状态变量满足执行条件后，开始执行操作；可在这个线程执行的时候，另一个线程同时修改了状态变量，导致状态变量不满足执行条件了。  

对于数据竞争和竞态条件问题，可以用**互斥**方案解决，可以统一归为：锁。  

### 二.活跃性问题
活跃性问题，指的是某个操作无法执行下去。常见的“死锁”就是一种活跃性问题，除了死锁之外，还有“活锁”和“饥饿”。  
**死锁**：线程互相等待，会一直等待下去，在技术上的表现形式是线程永久地“阻塞”了。  
**活锁**：线程虽然没有发生阻塞，但仍然会存在执行不下去的情况。  
**饥饿**：饥饿指的是线程因无法访问所需资源而无法执行下去的情况。解决饥饿的方法是公平地分配资源，在并发便成立，主要是使用公平锁。所谓公平锁，是一种先来后到的
方案，线程的等待是有顺序的，排在等待队列前面的线程会优先获得资源。  

### 三.性能问题
锁的过度使用可能会导致串行化范围过大，这样就不能发挥多线程的优势了。  
解决这个问题有如下方案：  
（1）使用无锁的算法和数据结构。例如线程本地存储（Thread Local Storage，TLS）、写入时复制（Copy-on-Write）、乐观锁等；




