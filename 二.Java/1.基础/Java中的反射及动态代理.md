#### 1.Java中的反射
每个类都有一个Class对象，包含了与类有关的信息。编译一个新类时，会产生一个同名的.class文件，其中保存着Class对象。类加载相当于Class对象的加载，类在第一次使用时才动态加载到JVM中。
可以使用Class.forName("com.mysql.jdbc.Driver")这种方式来控制类的加载，该方法返回一个Class对象。

反射可以提供运行时的类信息，且这个类可以在运行时才加载进来，甚至在编译时期该类的.class不存在也可以加载进来。
java.lang.reflect和Class一起对反射提供了支持，其类库最重要的三个类是：

（1）Field：表示类中的字段。  
（2）Method：表示类中的方法，可以使用invoke()方法调用。  
（3）Constructor：用来创建新的对象  

反射的应用：工厂模式。

#### 2.反射的优缺点
##### 优点
运行期类型判断，动态加载类，提高代码灵活度。

##### 缺点
如果一个功能可以不用反射实现，最好不要用。
（1）性能开销：反射涉及动态类型解析，JVM无法进行优化。因此，反射操作的效率会比非反射效率低的多。  
（2）安全限制：反射要求程序必须在一个没有安全限制的环境中运行。  
（3）内部暴露：反射允许代码执行一些正常情况下不被允许的操作（比如：访问私有属性和方法），所以使用反射可能会导致意料之外的副作用。

#### 3.Java中的动态代理
当想要给实现了某个接口的类中的方法，加一些额外处理，比如加日志，加事务等。
可以给这个类创建一个代理，这个类不仅包含原来方法的功能，还在其基础上添加了新的功能。
这个代理类不是定义好的，是动态生成的。

**动态代理的应用**：Spring的AOP、加事务、加权限、加日志。

#### 4.怎么实现动态代理
首先，定义一个接口，还要有一个InvocationHandler（将实现接口的类的对象传递给它）处理类。再有一个工具类Proxy。
利用InvocationHandler，拼接代理类源码，将其编译生成代理类的二进制码，利用加载器加载，并将其实例化产生代理对象，最后返回。

每个动态代理类都必须要实现InvocationHandler这个接口，且每个代理类的实例都关联到一个handler，当我们通过代理对象调用一个方法时，这个方法的调用就会被转发到由InvocationHandler这个接口的invoke方法来进行调用。







