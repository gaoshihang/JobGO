### 1.如何计算对象大小？
Java中，一个空Object对象大小为8byte。  
```
Object obj = new Object();
```

这个obj对象占用的空间是12byte：4 byte + 8 byte。4 byte是Java栈中保存引用所需要的空间。  

下面来计算这个对象的大小：  
```
Class Test{
  int count;
  boolean flag;
  Object obj;
}
```
其大小为：空对象大小（8） + int大小（4） + boolean大小（1） + 空Object引用大小（4）= 17 byte。但是因为Java在对象内存分配时都以8的整数倍来分，
所以其大小为24byte（24最接近17）。

### 2.判断垃圾可以回收的方法有？（重要）
#### （1）引用计数法
**基本思想**  
每个对象实例有一个引用计数，其他变量被复制为这个引用时，计数+1；某个引用超出生命周期或设置为新值时，计数-1。计数为0的会被回收。  
**缺陷**  
无法检测循环引用。如父对象有一个对子对象的引用，子对象反过来引用父对象，这样，他们的引用计数永远不为0。  

比如如下代码：  
```
public class Demo{
  MyObject object1 = new MyObject();
  MyObject object2 = new MyObject();
  
  object1.object = object2;
  object2.object = object1;
  object1 = null;
  object2 = null;
}

class MyObject{
  MyObject object;
}
```

#### （2）可达性分析
把所有的引用关系看作一个图，从一个节点GC ROOT开始，寻找对应应用节点，找到后，继续寻找这个节点的引用节点，所有的节点被找到后，剩余节点被认为是
没有被引用的节点。  

可以作为GC ROOTs的对象有：
* 虚拟机栈中引用的对象（栈帧中的本地变量表）；  
* 方法区中类静态属性引用的对象；  
* 方法区中常量引用的对象；  
* 本地方法栈中JNI（Native方法）引用的对象。  

**垃圾回收怎么开始？**  
栈是真正进行程序执行的地方，所以要获取哪些对象正在被使用，得从栈开始。  
出了栈以外，还有系统运行时的寄存器，也是存储程序运行时数据的。  
这样，从栈和寄存器中的引用为起点，找到堆中对象，再以这些对象找到其他对象，构建一棵对象树。  

### 3.被标记为垃圾的对象一定会被回收吗？  
**要真正宣告一个对象死亡，至少要经历两次标记过程。**

第一次：可达性分析。  
第二次：第一次标记后进行一次筛选，看此对象是否有必要执行finalize方法。在finalize方法中没有重新与引用链建立关系的，被进行第二次标记，并回收。  

### 4.Java中的引用类型
以下四种方式引用强度依次减弱。  
**强引用**  
普通引用。new XXX()。只要存在，永远不会回收。  

**软引用**  
有用但非必须对象。系统将要发生内存溢出时，会回收。  
```
SoftReference<String> softRef = new SoftReference<String>("hello");
System.out.println(softRef.get());
```
软引用可以用于构建内存敏感的高速缓存。  

**弱引用**  
也是用来描述非必需对象，其只能生存到下一次垃圾回收之前。垃圾回收器工作时，无论内存是否足够，都要回收掉。  
```
WeakReference<String> weakRef = new WeakReference<String>("hello");
System.out.println(weakRef.get());
System.gc();
System.out.println(weakRef.get());
```

**虚引用**  
**虚引用主要是用来追踪对象被垃圾回收器回收的活动**。无法通过虚引用来获取一个对象实例，其作用是在这个对象被回收时收到一个系统通知。  

### 5.Java中的内存泄露（重要）
#### 基本概念
存在一些不会再被使用但没有回收的对象，这些对象有以下两个特性：  
（1）可达  
（2）无用  

#### 根本原因
长生命周期对象持有短生命周期对象的引用，这时可能发生内存泄露。尽管短生命周期的对象不再需要，但是因为长生命周期对象拥有对其的引用，导致不能回收。

#### 发生情况
（1）静态集合类；  
（2）集合里面的对象属性被修改后，再调用remove不起作用；  
（3）监听器：释放对象时没有删除监听器；  
（4）各种连接  
（5）内部类  
（6）单例模式  

#### 如何避免
（1）尽量不要使用static成员变量，减少生命周期；  
（2）及时关闭资源；  
（3）不用的对象，手动设置为null  

### 6.常用的垃圾收集算法（重要）
#### （1）标记-清除算法（Mark-Sweep）  
不需要进行对象移动，存活对象较多的情况下极其高效。但是会造成内存碎片。  

#### （2）复制算法
这个算法为了克服内存碎片问题。它把堆分为对象面和多个空闲面，当对象面满了的时候，将活动对象复制到空闲面，清除垃圾对象，这样空闲面就称为了对象面。

#### （3）标记-整理算法（Mark-Compact）
在回收不存活对象时，将所有存活对象向左端空闲空间移动，并更新相应指针。此算法添加了移动对象过程，成本更高，但没有内存碎片。  

#### （4）分代收集算法
**其核心思想是根据对象存活的生命周期将内存划分为若干个不同的区域**。一般将堆区划分为老年代、新生代，堆区之外还有一个永久代。  

### 7.年轻代和老年代分别应该采用什么算法？
#### 年轻代（以 复制算法 为主）
（1）年轻代的目标是尽可能快的收集掉那些生命周期短的对象。  
（2）新生代内存按照8:1:1分为一个Eden区和两个survivor区。对象在Eden中分配，回收时，将Eden区存活对象复制到survivor0区，清空eden。
当这个survivor0也满了时，将eden和survivor0存活对象复制到survivor1，清空eden和survivor0.循环往复。  
（3）当survivor1不足以存放eden和survivor0的存活对象时，将其直接存入老年代。  

#### 老年代（以 Mark-Compact为主）
（1）在年轻代中经历了N次垃圾回收后仍然存活的对象，会被放到老年代中。年老代中存放的是一些生存周期较长的对象。  
（2）内存比新生代大很多（大概比例是1:2），当老年代满时会出发Major GC，即Full GC。  

### 8.什么是浮动垃圾？什么是内存碎片？
在应用运行的同时进行垃圾回收，有些垃圾可能再垃圾回收的过程中产生，这样就造成了“Floating Garbage”，这些垃圾需要在下一次垃圾回收时被回收掉。    
不同Java对象存活时间是不同的，因此，在程序运行一段时间后，如果不进行内存整理，就会有出现零碎的内存碎片。**内存碎片带来最主要的问题是无法分配大块的内存空间，以及程序运行效率较低**。垃圾回收算法中的“复制”和“标记-整理”都可以解决内存碎片问题。 

### 9.常用垃圾收集器有哪些（重要）？
**什么是stop-the-world？**
垃圾收集器因为要进行GC而停止了应用程序的执行。  
多数垃圾收集器都会发生。  
垃圾收集器都通过降低stop-the-world的时间，提升垃圾收集的效率。  

新生代垃圾收集器：Serial、ParNew、Parallel Scavenge  
老年代垃圾收集器：CMS、Serial Old（MSC）、Parallel Old  
除此之外，还有G1，同时适用于新生代与老年代。  

#### （1）Serial收集器（复制算法）
新生代单线程收集器，标记和清理都是单线程，优点是简单高效。在工作时会暂停所有用户线程的执行，stop-the-world。
![Serial收集器](http://images2015.cnblogs.com/blog/331425/201606/331425-20160624174239719-1127409322.png)

#### （2）ParNew收集器（停止-复制算法）
新生代可以认为是Serial收集器的多线程版本，在多核CPU环境下有着比Serial更好的表现。  
![ParNew收集器](http://images2015.cnblogs.com/blog/331425/201606/331425-20160624174241188-1502278645.png)

#### （3）Parallel Scavenge收集器（停止-复制算法）
新生代并行收集器，追求高吞吐量，高效利用CPU。吞吐量一般为99%，吞吐量=用户线程时间/（用户线程时间+GC线程时间）。适合后台应用等对交互相应要求不高的场景。是server级别默认采用的GC方式、  

#### （4）Serial Old收集器（标记-整理算法）
老年代单线程收集器，Serial收集器的老年代版本。

#### （5）Parallel Old收集器（停止-复制算法）
Parallel收集器的老年代版本，并行收集器，吞吐量优先。  

#### （6）CMS（Concurrent Mark Sweep）收集器（标记-清除算法）
CMS是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。  
CMS是使用标记-清除算法实现的，所以在使用时，会产生大量的内存碎片。  
![CMS垃圾收集器](http://images2015.cnblogs.com/blog/331425/201606/331425-20160624174245500-1388590060.png)  
具体请见：https://www.cnblogs.com/ityouknow/p/5614961.html  

#### （7）G1垃圾收集器
G1收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。  

### 10.谈谈对CMS垃圾收集器的理解
CMS的整个过程分为以下四步：  
（1）初始标记：记录直接与root连接的对象，stop-the-world，速度很快；  
（2）并发标记：GC线程和用户线程同时运行，标记所有的可达对象；  
（3）重新标记：这个阶段是为了修正并发标记阶段因为用户程序继续运行而导致标记产生变动的那一部分对象。（比初始标记时间稍长，远远短于并发标记阶段）。  
（4）并发清除： 开启用户线程，同时GC线程开始对标记的区域做清扫。  

**优点**  
并发收集、低停顿；  

**缺点**  
对CPU资源敏感。  
无法处理浮动垃圾。  
大量空间碎片。  


### 11.谈谈对G1垃圾回收器的理解（重要）
**垃圾回收的瓶颈**  
传统垃圾回收最大的问题，是无法解决Full GC带来的应用暂停问题。虽然考虑了实时性要求而提供了并发回收器，但是受限于分代垃圾回收的内存划分模型，其效果不是很理想。  

G1吸取了增量收集优点，把整个堆划分为一个一个等大小的region。内存的回收和划分都以region为单位；同时，也吸取了CMS的特点，把垃圾回收过程分为几个阶段，分散一个垃圾回收过程。同时，他也支持分代的垃圾收集。  
为了达到对回收时间的可预计性，G1在扫描了region后，对其中活跃对象的大小进行排序，首先收集活跃对象小的region，以便快速回收空间。 

### 12.对垃圾回收策略的理解/垃圾回收时机？（重要）
#### （1）Minor/Scavenge GC
对象都创建在新生代的Eden区，当Eden区满了后，触发新生代的minor GC，将Eden区和非空闲survivor区存活的对象复制到另一个空闲的survivor区中。保证一个survivor是空的。**新生代Minor GC就是在两个survivor区之间互相复制存活对象，直到survivor区满为止**。  
大部分对象都是从Eden区开始的，且Eden区不会分配的很大，所以Eden区的GC会频繁的进行。所以这里要用一些速度快、效率高的算法，使得Eden区能尽快的空闲出来。  
#### （2）Full GC
Full GC对整个堆进行整理，包括新生代和老年代，所以其比Minor GC要慢，因此要尽可能减少Full GC的次数。**在对JVM的调优中。很大一部分是对于Full GC的调节**。  

**Minor GC有如下可能会导致Full GC**  
* 调用System.gc()，会**建议**虚拟机执行Full GC。  
* 老年代空间不足。主要原因是大对象直接进入老年代，所以为了避免，应当尽量不要创建过大的对象以及数组。    
* 空间分配担保失败：使用复制算法的Minor GC需要老年代的内存空间作担保，如果担保失败，执行一次Full GC。  

### 13.谈谈对内存分配的理解？大对象如何分配？空间分配担保？
（1）对象优先在Eden区分配，当Eden空间不够时，发起Minor GC。  
（2）大对象直接进入老年代。  
（3）长期存活的对象进入老年代。  
（4）动态对象年龄判定  
**（5）空间分配担保**  
* 在发生Minor GC前，JVM会先检查老年代最大可用连续空间，若其大于新生代所有对象总空间，则Minor GC可以确认是安全的。  
* 如果不成立，虚拟机会查看HandlePromotionFailure设置是否允许担保失败，若允许，则继续检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，则尝试进行一次Minor GC；若不允许，那么进行一次Full GC。  





































