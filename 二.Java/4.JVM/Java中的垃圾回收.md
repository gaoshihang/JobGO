### 1.如何计算对象大小？
Java中，一个空Object对象大小为8byte。  
```
Object obj = new Object();
```

这个obj对象占用的空间是12byte：4 byte + 8 byte。4 byte是Java栈中保存引用所需要的空间。  

下面来计算这个对象的大小：  
```
Class Test{
  int count;
  boolean flag;
  Object obj;
}
```
其大小为：空对象大小（8） + int大小（4） + boolean大小（1） + 空Object引用大小（4）= 17 byte。但是因为Java在对象内存分配时都以8的整数倍来分，
所以其大小为24byte（24最接近17）。

### 2.判断垃圾可以回收的方法有？（重要）
#### （1）引用计数法
**基本思想**  
每个对象实例有一个引用计数，其他变量被复制为这个引用时，计数+1；某个引用超出生命周期或设置为新值时，计数-1。计数为0的会被回收。  
**缺陷**  
无法检测循环引用。如父对象有一个对子对象的引用，子对象反过来引用父对象，这样，他们的引用计数永远不为0。  

比如如下代码：  
```
public class Demo{
  MyObject object1 = new MyObject();
  MyObject object2 = new MyObject();
  
  object1.object = object2;
  object2.object = object1;
  object1 = null;
  object2 = null;
}

class MyObject{
  MyObject object;
}
```

#### （2）可达性分析
把所有的引用关系看作一个图，从一个节点GC ROOT开始，寻找对应应用节点，找到后，继续寻找这个节点的引用节点，所有的节点被找到后，剩余节点被认为是
没有被引用的节点。  

可以作为GC ROOTs的对象有：
* 虚拟机栈中引用的对象（栈帧中的本地变量表）；  
* 方法区中类静态属性引用的对象；  
* 方法区中常量引用的对象；  
* 本地方法栈中JNI（Native方法）引用的对象。  

**垃圾回收怎么开始？**  
栈是真正进行程序执行的地方，所以要获取哪些对象正在被使用，得从栈开始。  
出了栈以外，还有系统运行时的寄存器，也是存储程序运行时数据的。  
这样，从栈和寄存器中的引用为起点，找到堆中对象，再以这些对象找到其他对象，构建一棵对象树。  

### 3.被标记为垃圾的对象一定会被回收吗？  
**要真正宣告一个对象死亡，至少要经历两次标记过程。**

第一次：可达性分析。  
第二次：第一次标记后进行一次筛选，看此对象是否有必要执行finalize方法。在finalize方法中没有重新与引用链建立关系的，被进行第二次标记，并回收。  

### 4.Java中的引用类型
以下四种方式引用强度依次减弱。  
**强引用**  
普通引用。new XXX()。只要存在，永远不会回收。  

**软引用**  
有用但非必须对象。系统将要发生内存溢出时，会回收。  
```
SoftReference<String> softRef = new SoftReference<String>("hello");
System.out.println(softRef.get());
```
软引用可以用于构建内存敏感的高速缓存。  

**弱引用**  
也是用来描述非必需对象，其只能生存到下一次垃圾回收之前。垃圾回收器工作时，无论内存是否足够，都要回收掉。  
```
WeakReference<String> weakRef = new WeakReference<String>("hello");
System.out.println(weakRef.get());
System.gc();
System.out.println(weakRef.get());
```

**虚引用**  
**虚引用主要是用来追踪对象被垃圾回收器回收的活动**。无法通过虚引用来获取一个对象实例，其作用是在这个对象被回收时收到一个系统通知。  

### 5.Java中的内存泄露（重要）
#### 基本概念
存在一些不会再被使用但没有回收的对象，这些对象有以下两个特性：  
（1）可达  
（2）无用  

#### 根本原因
长生命周期对象持有短生命周期对象的引用，这时可能发生内存泄露。尽管短生命周期的对象不再需要，但是因为长生命周期对象拥有对其的引用，导致不能回收。

#### 发生情况
（1）静态集合类；  
（2）集合里面的对象属性被修改后，再调用remove不起作用；  
（3）监听器：释放对象时没有删除监听器；  
（4）各种连接  
（5）内部类  
（6）单例模式  

#### 如何避免
（1）尽量不要使用static成员变量，减少生命周期；  
（2）及时关闭资源；  
（3）不用的对象，手动设置为null  

### 6.常用的垃圾收集算法（重要）
#### （1）标记-清除算法（Mark-Sweep）  
不需要进行对象移动，存活对象较多的情况下极其高效。但是会造成内存碎片。  

#### （2）复制算法
这个算法为了克服内存碎片问题。它把堆分为对象面和多个空闲面，当对象面满了的时候，将活动对象复制到空闲面，清除垃圾对象，这样空闲面就称为了对象面。

#### （3）标记-整理算法（Mark-Compact）
在回收不存活对象时，将所有存活对象向左端空闲空间移动，并更新相应指针。此算法添加了移动对象过程，成本更高，但没有内存碎片。  

#### （4）分代收集算法
**其核心思想是根据对象存活的生命周期将内存划分为若干个不同的区域**。一般将堆区划分为老年代、新生代，堆区之外还有一个永久代。  

### 7.年轻代和老年代分别应该采用什么算法？
#### 年轻代（以 复制算法 为主）
（1）年轻代的目标是尽可能快的收集掉那些生命周期短的对象。  
（2）新生代内存按照8:1:1分为一个Eden区和两个survivor区。对象在Eden中分配，回收时，将Eden区存活对象复制到survivor0区，清空eden。
当这个survivor0也满了时，将eden和survivor0存活对象复制到survivor1，清空eden和survivor0.循环往复。  
（3）当survivor1不足以存放eden和survivor0的存活对象时，将其直接存入老年代。  

#### 老年代（以 Mark-Compact为主）
















