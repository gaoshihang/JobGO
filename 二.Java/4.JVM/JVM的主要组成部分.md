### 1.JVM主要组成部分
（1）类加载器  
（2）运行时数据区  
（3）执行引擎  
（4）本地库接口  

**各组件作用**：首先通过类加载器把Java代码转换成字节码，运行时数据区将字节码加载到内存中，字节码只是Java的规范，不能直接交给底层操作系统去执行，还需要执行引擎将字节码翻译成底层系统指令，交给CPU执行，这其中需要调用其他语言的本地库接口来实现程序功能。

### 2.JVM中的运行时数据区（重要）
运行时数据区组成部分如下图所示：  
![微信图片_20191016133923.jpg](https://upload-images.jianshu.io/upload_images/2818100-39ae9775ed304a36.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

运行时数据区分为两部分：分为线程共享和线程私有的。
#### 线程私有
**（1）程序计数器**  
一块较小的内存空间，用来标识当前线程所执行的字节码的行号。  
字节码解释器工作时就是通过改变这个计数器的值来选取下一条要执行的字节码指令，程序的循环、跳转、异常处理等都依赖于这个计数器。  
**这是JVM中唯一个没有规定任何OutOfMemoryError情况的区域。**

**（2）Java虚拟机栈**  
描述的是Java方法执行的内存模型：每个方法在执行的时候都会创建一个栈帧（用于存储局部变量表、操作数栈、动态链接、方法出口等信息）。每个方法从调用直至执行完毕，就对应着一个栈帧在虚拟机栈中入栈和出栈的过程。  
其中，局部变量表存放基本数据、对象引用和returnAddress类型。其空间单位是槽（Slot），double和long类型（64位）会占用两个Slot。
**Java虚拟机栈有两种异常状况**：线程请求栈的深度大于虚拟机所允许深度，抛出StackOverFlowError；扩展时无法申请到内存，抛出OOM异常。

**（3）本地方法栈**  
与虚拟机栈类似，区别在于本地方法栈服务于native方法。抛出的异常也与虚拟机栈相同。  

#### 线程共有
**（4）Java堆**  
在JVM启动时创建，唯一目的是：存放Java对象实例。  
堆是垃圾回收器管理的主要区域，堆分为新生代和老年代，同时，可能划分出多个线程私有的分配缓冲区（TLAB，Thread Local Allocation Buffer）。  
堆无法扩展时，会抛出OOM异常。  

**（5）方法区**  
用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。  
这个区域回收的目标主要是针对常量池的回收和对类型的卸载。  
当方法区无法满足内存分配需求时，抛出OOM异常。  

**运行时常量池（Runtime Constant Pool）**  
方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一些信息是常量池，用于存放编译器生成的各种字面量和符号引用，这部分内存在类加载后进入方法区的运行时常量池中存储。  
https://mp.weixin.qq.com/s/ey02Jz6NOqSPA_ylMLtRDA  

**直接内存（Direct Memory）**
并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。不受Java堆大小的限制，但是受到本地总内存大小以及处理器寻址空间的限制。也会出现OOM异常。
https://mp.weixin.qq.com/s/YjPk0GEl5DbXGqPNhb77NQ  

### 3.堆和栈的区别
（1）栈是线程私有的，堆是线程共有的；  
（2）栈从存放的是局部变量表（基本数据类型、对象引用），堆中存放对象实例；  
（3）堆中存放的对象实例大小是动态变化的；栈中一个对象只对应一个4byte的引用。  

**为什么基本类型不放在堆中？**  
基本类型占用空间为1~8字节，较少，且长度固定，栈中存储就够了。

**为什么要区分堆和栈？**  
（1）栈代表了处理逻辑，堆代表了数据，分开使得处理逻辑更为清晰；  
（2）堆中的内容可以被多个线程共享，一方面，这提供了一种有效的数据交换方式（如：共享内存），另一方面，堆中共享常量和缓存可以被所有线程访问，节省空间。















