### 1.什么是类加载机制？（重要）
虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是类加载机制。  
类从被加载到内存中，到卸载出内存为止，其整个生命周期包括七个阶段：**加载、验证、准备、解析、初始化、使用、卸载**。其中验证、准备、解析3个部分称为连接，
如图所示：  
![类加载的7个阶段](https://img-blog.csdn.net/20180105165447562?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZmVpZ2Vzd2p0dQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

### 2.类加载机制各阶段作用
#### （1）加载
* 通过一个类的全限定名获取定义此类的二进制字节流；  
* 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构；  
* 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问接口。  

#### （2）验证
确保Class文件中的字节流包含的信息符合虚拟机的规范，不会危害虚拟机自身安全。其分为四个阶段的检验动作：**文件格式校验、元数据校验、字节码校验、符号引用校验。**
**文件格式校验**  
验证字节流是否符合Class文件规范，且能被当前版本的虚拟机处理。只有通过这个阶段的验证，字节流才会进入内存的方法区进行存储，后面的三个阶段都是基于方法区的存储结构进行的，不会再直接操作字节流。  

**元数据验证**  
语义分析，确保其描述信息符合Java语言规范的要求，保证不存在不符合Java语言规范的元数据信息。  

**字节码验证**  
数据流和控制流分析，确保类的方法在运行时不会做出危害虚拟机安全的行为。  

**符号引用验证**  
这个阶段的校验发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三个阶段——解析阶段中发生。符号引用验证的目的是确保解析动作能正常进行。  

#### （3）准备
准备阶段正式为类变量分配内存并设置类变量初始值。这时候进行内存分配的仅包含类变量（被static修饰的变量），不包括实例变量，其内存都将在方法区中进行分配，而实例变量会在对象实例化时随着对象一起分配在Java堆中。**实例化不是类加载的过程，类加载发生在所有实例化之前，且只执行一次**。  
初始值是默认值0或false或null。如果类变量是常量（final），那么会按照表达式来进行初始化，而不是赋值为0。例如：  
```
public static final int value = 123;
```

#### （4）解析
虚拟机将常量池内的符号引用替换为直接引用的过程。  

#### （5）初始化
初始化阶段是执行类的<clinit>()方法的过程。  
  
### 3.有哪些类加载器？分别的作用？
#### （1）Bootstrap ClassLoader（启动类加载器）  
C++实现的，是虚拟机自身的一部分。负责将存在JAVA_HOME/lib目录中的，或者被-Xbootclasspath参数指定的路径中的类库加载到虚拟机内存中。  
无法被Java程序直接引用。  

#### （2）其他类加载器
Java实现，独立于JVM外部，全部继承自抽象类java.lang.ClassLoader。包含扩展类加载器和应用程序类加载器。  
##### 扩展类加载器（Extension ClassLoader）
由sun.misc.Launcher$ExtClassLoader实现，负责加载JAVA_HOME/lib/ext目录中的，或者被java.ext.dirs所指定的路径中的所有类库，开发者可以直接使用。  

##### 应用程序类加载器（Application ClassLoader）
由sun.misc.Launcher$AppClassLoader实现。负责加载用户路径（ClassPath）所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。  

### 4.类与类加载器的关系
任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性。  
换句话说：如果要比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那么这两个类就必定不相等。  

### 5.类加载机制中的双亲委派模型（重要）
应用程序一般由上述三种类加载器相互配合加载，如果有必要，还可以加入自己定义的类加载器，关系如下：  
![双亲委派模型](https://img-blog.csdn.net/20160506184936657)

**工作过程**  
类加载器收到类加载请求，首先不会自己尝试加载这个类，而是把这个请求委派给父类加载器完成。因此所有的加载类请求最终会传送到顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己加载。  

**使用双亲委派的好处**  
类随着其类加载器具备了一种带有优先级的层次关系。  
例如：java.lang.Object，存放在rt.jar中，无论哪个类加载器需要加载这个类，最终会委派给最顶端的启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类（使用同一个类加载器加载）。  
如果没有双亲委派模型，由各个类自己去加载，如果用户编写了一个java.lang.Object类，并放在程序的ClassPath中，那么系统将出现多个不同的Object类，Java类型体系中最基础的行为就无法保证。  





















