### 1.Java内存模型的理解（重要）
处理器和内存不是同数量级，所以要在中间加上一个中间层，也就是高速缓存，这就引出了缓存一致性问题。  
在多处理器系统中，每个处理器都有自己的高速缓存，但是他们又共享同一个主内存，有可能操作同一位置引起各自缓存不一致。  

Java内存模型（JMM）屏蔽掉了各种硬件和操作系统的内存访问差异，使得Java程序在各种平台下都能达到一致性的内存访问效果。  
![Java内存模型](https://upload-images.jianshu.io/upload_images/4899162-66736384361f6b8b.png?imageMogr2/auto-orient/strip|imageView2/2/w/812/format/webp)

**主内存与工作内存**  
JMM的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。  
JMM规定了所有变量都存储在主内存中，每个线程有自己的工作内存，保存主内存的副本拷贝，以及私有变量，不同线程不能访问其他工作内存中的变量。**线程间变量值的传递需要通过主内存完成**。  

### 2.内存间的交互操作有哪些？需要满足什么规则？
一个变量如何从主内存拷贝到工作内存，如何从工作内存同步主内存，JMM中定义了以下八种操作：  
（1）lock（锁定）：作用于主内存的变量，把一个变量标志为一个线程独占的状态；  
（2）unlock（解锁）：作用于主内存变量，把处于锁定状态的变量释放出来；  
（3）read（读取）：作用于主内存变量，把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用；  
（4）load（载入）：作用于工作内存，把read的值从主内存传输到工作内存，放入其变量副本；  
（5）use（使用）：作用于工作内存，把其中一个变量的值传递给执行引擎，每当JVM遇到一个需要使用到变量的字节码指令时会执行这个操作；  
（6）assign（赋值）：作用于工作内存的变量，把一个执行引擎接收到的值赋值给其工作内存的变量，每当JVM遇到一个需要给变量赋值的操作时会执行这个操作；  
（7）store（存储）：作用于工作内存，把一个变量的值传递到主内存中，以便随后的write操作使用；  
（8）write（写入）：作用于主内存。把store操作从工作内存中得到的变量值放入主内存的变量中；  




