### 1.TCP和UDP的主要特点
#### （1）TCP
* TCP是面向连接的。  
* 每条TCP连接只能有两个端点，每一条TCP连接只能是点对点的。  
* 提供可靠的交付服务。  
* 提供全双工通信。  
* 面向字节流。  

#### （2）UDP
* UDP是无连接的。  
* UDP尽最大努力交付，不保证可靠交付。  
* 面向报文。  
* 没有拥塞控制，网络出现拥塞不会使源主机的发送速率降低。  
* 支持一对一、一对多、多对一和多对多的交互通信。  
* UDP首部开销8字节，少于TCP的20字节。  

### 2.TCP的三次握手过程（重要）
![TCP三次握手](http://blog.chinaunix.net/attachment/201304/8/22312037_1365405910EROI.png)  
最初Client和Server都出于CLOSED状态，Client主动打开连接，Server被动打开连接。  
一开始，Server出于LISTEN状态，等待客户端的连接请求。  
**第一次握手**  
Client向Server发出连接请求报文段，这时首部中的同部位SYN=1，同时选择一个初始序号seq=x。这时，Client进入SYN-SENT状态。  
**第二次握手**  
Server接收到连接请求报文后，如果同意建立连接，则向A发送确认。确认报文段中把SYN位和ACK位都置1，确认号是ack=x+1，同时也为自己选择一个初始序号seq=y。
完成后Server进入SYN-RCVD状态。  
**第三次握手**  
Client接收到Server的确认后，还要向Server给出确认。确认报文段的ACK置1，确认号ack=y+1，而自己的序号seq=x+1。此时，TCP连接建立，Cleint进入ESTABLISED状态。  

### 3、为什么两次握手不可以（重要）
为了防止已经失效的连接请求报文段突然又传送到了Server，因而产生错误。比如下面情况：Client发出的第一个连接请求报文段并没有丢失，而是在网络结点长时间滞留了，
以至于延误到连接释放以后的某个时间段才到达Server。本来这是一个早已失效的报文段，但是Server收到此失效的连接请求报文段后，就误认为Client又发出一次新的连接
请求。于是向Client发出确认报文段，同意建立连接。  
对于这种情况，如果不进行第三次握手，Server发出确认后就认为新的运输连接已经建立了，并一直等待Client发来数据，Server的许多资源就这样浪费。  
如果采用三次握手，由于Client实际并没有建立连接请求，所以不会回应Server的确认，也不会向Server发送数据，Server由于收不到确认，就知道Client并没有建立连接。

### 4.TCP的四次挥手过程（重要）
传输结束后，通信双方都可以释放连接。现在Client和Server都出于ESTABLISHED状态。  
![TCP四次挥手](https://img-blog.csdn.net/20180717204202563?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTUwMzE2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)  
**第一次挥手**  
Client先向其TCP发出连接释放报文段，停止再发送数据，主动关闭TCP连接。FIN=1,seq=u,（等于前面已传送过的数据的最后一个字节的序号加1），这时Client进入
FIN-WAIT-1（终止等待1）状态，等待Server的确认。  
**第二次挥手**  
Server收到连接释放报文段后立即发出确认，确认号是ack=u+1，而这个报文段自己的序号是v（等于Server前面已经传送过的数据的最后一个字节的序号加1），然后Server
就进入CLOSE-WAIT（关闭等待）状态。TCP服务端进程这时应通知高层应用进程，因而从Client到Server这个方向的连接就释放了，这时的TCP连接处于半关闭状态，即Client
已经没有数据要发送了，但Server若发送数据，Client仍要接收。也就是说，从Server到Client这个方向的连接并未关闭，这个状态可能会持续一段时间。  
Client收到Server的确认后，就进入FIN-WAIT-2（终止等待2）状态，等待Server发出的连接释放报文段。  
**第三次挥手**  
若Server已经没有要向Client发送的数据，其应用进程就通知TCP释放连接。这时Server发出的连接释放报文段必须使FIN=1。假定Server的序号为w（在半关闭状态，Server
可能又发送了一些数据）。Server还必须重复上次已发送过的确认号ack=u+1.这时Server就进入LAST-ACK（最后确认）状态，等待Client的确认。  
**第四次挥手**  
Client在收到Server的连接释放报文后，必须对此发出确认。然后进入TIME-WAIT（时间等待）状态。  
现在TCP连接还没有释放掉，必须经过时间等待计时器设置的时间2MSL（MSL：最长报文段寿命）后，Client才能进入到CLOSED状态，结束这次TCP连接。  

### 5.为什么TIME-WAIT状态必须等待2MSL的时间？
* 为了保证A发送的最后一个ACK报文能够到达B。这个报文有可能丢失，因而使处在LAST-ACK状态的B收不到对已发送的FIN+ACK报文段的确认。B会超时重传这个FIN+ACK
报文段，而A就能在2MSL时间内收到这个重传的FIN+ACK报文段。接着A重传一次确认，重新启动2MSL计时器。最后，A和B都正常进入到CLOSED状态。  
* 防止已失效的连接请求报文段出现在本连接中。A在发送完最后一个ACK报文段后，再经过时间2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。
这样就可以使下一个连接中不会出现这种旧的连接请求报文段。  

### 6.TCP协议是如何保证可靠传输的？
（1）数据包校验  
检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段且不给出响应，这时TCP超时后会重发数据。  
（2）对失序数据包重排序  
（3）丢弃重复数据  
（4）应答机制  
（5）超时重发  
（6）流量控制  
TCP连接的两端都有固定大小的缓冲空间。TCP的接收端只允许只允许另一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是
流量控制。**TCP使用的流量控制协议是可变大小的滑动窗口协议**。  

### 7.什么是滑动窗口？
TCP利用滑动窗口实现流量控制的机制。早期网络通信中，通信双方不会考虑网络的拥挤情况直接发送数据，由于大家不知道网络拥塞状况，同时发送数据，导致中间节点
阻塞掉包，谁也发不了数据。  
TCP中采用滑动窗口进行传输控制，滑动窗口大小意味着接收方还有多大缓冲区可以接受发送方的数据。发送方可以根据滑动窗口的大小控制要发送多少字节的数据。当滑动
窗口为0时，发送方不再发送数据报。  

### 8.TCP的拥塞控制
拥塞控制和流量控制不同，前者是一个全局性的过程，后者指点对点通信量的控制。  
在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就会变坏，这就叫做“拥塞”。  
拥塞控制就是为了防止过多数据注入到网络中，为了进行拥塞控制，TCP发送方要维持一个拥塞窗口（cwnd）的状态变量，其大小取决于网络的拥塞程序，且动态变化。发送方让
自己的发送窗口取为拥塞窗口和接收方的接收窗口中较小的一个。  

TCP的拥塞控制采用了4中算法：  
（1）慢开始  
其思想是当主机开始发送数据，如果立即把大量数据字节注入到网络，可能会引起网络阻塞，因为现在还不知道网络的具体情况。所以，较好的方法是先探测一下，由小到大
逐渐增大发送窗口，cwnd初始值为1，每经过一个传播轮次，cwnd加倍。  
（2）拥塞避免  
其思路是让拥塞窗口cwnd缓慢增大，每经过一个往返时间RTT就把发送方的cwnd+1。  
（3）













