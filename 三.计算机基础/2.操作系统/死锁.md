### 1.什么是死锁
多个进程在运行过程中因争抢资源而造成的一种僵局，当进程处于这种状态时，若无外力作用，都无法再向前推进。一种典型情况如下所示：  
![死锁](https://img-blog.csdn.net/20180922173936964?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hkMTIzNzA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)  

#### 产生死锁的原因
当两个或以上进程（线程）占有自身不可剥夺资源，并请求对方不可剥夺资源时，会导致每个进程都无法向前推进，这就是死锁。  

#### 死锁产生的必要条件
（1）互斥条件：进程要求对所分配的资源进行排他性控制，一段时间内某资源仅为一进程所占有。  
（2）请求和保持条件：当进程因请求资源而阻塞时，对已获得的资源保持不放。  
（3）不剥夺条件：资源不可剥夺，只能在使用完自己释放。  
（4）环路等待条件：发生死锁时，必然存在一个进程-资源的环形链。  

### 2.解决死锁的基本方法
* 预防死锁  
* 避免死锁  
* 检测死锁  
* 解除死锁  

#### 怎么预防死锁？
（1）破坏请求条件：一次性分配所有资源，这样就不会再有请求了；  
（2）破坏保持条件：只要有一个资源得不到分配，也不给这个进程分配其他的资源；  
（3）破坏不可剥夺条件：当某进程获得了部分资源，但得不到其他资源，则释放已有资源；  
（4）破坏环路等待条件：系统给每类资源赋予一个编号，每个进程按编号递增顺序请求资源，释放则相反。  

#### 怎么避免死锁？
（1）银行家算法  
当进程首次申请资源时，测试该进程对资源的最大需求量，若系统现存资源量可以满足其最大资源量，则按当前申请量分配，否则推迟分配。  
当进程在执行中继续申请资源时，先测试该进程已占用的资源数与本次申请资源数之和是否超过了该进程对资源的最大需求量。若超过则拒绝分配资源。若没有超过，则
再测试系统现存的资源能够满足该进程尚需的最大资源量，若满足则按当前的申请量分配，否则延迟分配。  

（2）安全序列  
指系统能按某种进程推进顺序，为每个进程分配其所需的资源，直至满足每个进程对资源的最大需求，使每个进程都可以顺序完成。这种推进顺序就叫安全序列。
**银行家算法的核心就是找到一个安全序列**。  

#### 怎么解除死锁？
（1）资源剥夺  
挂起某些死锁进程，并抢占其资源，将这些资源分配给其他死锁进程。  

（2）撤销进程  
强制撤销部分、甚至全部死锁进程并剥夺这些进程的资源。  

（3）进程回退  
让一个或多个进程回退到足以避免死锁的地步，进程回退时自愿释放资源而不是被剥夺。  












