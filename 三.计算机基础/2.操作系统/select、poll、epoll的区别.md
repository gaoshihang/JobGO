select、poll、epoll都是IO多路复用的机制。I/O多路复用就是通过一种机制，监视多个描述符，一旦有描述符就绪，就通知程序进行相应的读写。  
**但select、poll、epoll本质上都是同步I/O，因为它们都需要在读写事件就绪后自己负责进行读写，这个过程是阻塞的。而异步I/O无需自己进行读写。**   

### 1.select
select是采用轮询的方式获知I/O事件的发生，其具有O(n)的无差别轮询复杂度。
select本质上是通过检查存放fd标志位的数据结构来进行下一步处理，这样带来的缺点是：  
（1）单个进程能监控的fd数量被限制，即能监听端口的大小有限，受制于系统内存；  
（2）对socket进行扫描时是线性的，即采用轮询方式，效率较低；  
（3）需要维护一个用来存放大量fd的数据结构，这使得用户空间和内核空间在传递该结构时复制开销大。  

select的调用过程如下：  
![select调用过程](https://images2018.cnblogs.com/blog/137084/201806/137084-20180611142415772-1018872947.png)  


### 2.poll
本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态，**但是它没有最大连接数的限制**，因为它基于链表来存储。  
poll有一个特点是“水平触发”，即如果报告了fd后，没有被处理，下次会再次报告该fd。  

### 3.epoll
epoll可以理解为event poll（事件驱动），不同于轮询，它会把哪个流发生了怎样的I/O事件通知我们。  
epoll有LT和ET两种触发模式，LT为默认模式，ET是“高速”模式。LT时，只要这个fd还有数据可读，则每次epoll_wait都会返回它的事件，提醒用户程序操作；而在
ET下，只提示一次，所以read一个fd时一定要把它的buffer读光。  
epoll使用“事件”的就绪通知方式，通过epoll_ctl注册fd，一旦该fd就绪，内核会采用类似callback机制激活该fd，epoll_wait可以收到通知。  

epoll的优点：  
（1）没有最大并发连接数限制；  
（2）效率提升，且不会收到fd数量的影响；  
（3）内存拷贝，epoll使用mmap减少复制开销。  

