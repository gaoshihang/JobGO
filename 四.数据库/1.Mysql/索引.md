### 1.索引介绍
索引的出现是为了提高数据的查询效率。对于数据库表而言，索引就是其“目录”。  
索引也会带来一些负面影响：  
* 创建索引和维护索引需要耗费时间，这个时间随着数据量的增加而增加；  
* 索引需要额外的存储空间；  
* 当对表进行数据操作时，相应的索引也要动态维护，这就降低了数据的维护速度；  

#### 建立索引的原则
（1）在最频繁使用的，用来缩小查询范围的字段上建立索引；  
（2）在频繁使用的，需要排序的字段上建立索引；  

#### 不适合建立索引的情况
（1）查询中很少涉及的列或者重复值比较多的列，不适合建立索引；  
（2）对于一些特殊的数据类型，不宜建立索引，比如：文本字段（text）等。  

### 2.索引底层使用的数据结构
索引使用的数据结构和具体存储引擎的实现有关，MySQL中使用较多的索引有hash索引、B+树索引等。  
其中InnoDB存储引擎默认索引实现为B+树索引。  

#### 索引的常见模型
索引有三种常见的数据结构，分别为哈希表、有序数组和搜索树。  

用哈希表做索引时，其数据的哈希值并不是递增的，这带来的缺点是，哈希表在做区间查询时的速度是很慢的，每次都要全部扫描一遍。所以，**哈希表只适用于等值查询的场景。**  

而有序数组在等值查询和范围查询场景中的性能都非常优秀，但是，**在更新时就麻烦了，每往中间插一个记录就得挪动后面所有记录。因此，有序数组只适用于静态存储引擎。**  

对于搜索树来说，如果使用二叉树，则其高度就是需要访问的数据块数量，这严重影响查询的效率。所以，要让一个查询尽可能快，就要尽可能降低其查询访问到的数据块。这时，我们就应该使用**N叉树**。  

#### 什么是B+树？
（1）B+树是基于B树和叶子节点顺序访问指针进行实现，具有B树的平衡性，且通过顺序访问指针来提高区间查询的速度。  
（2）在B+树中，一个节点中的key从左到右是非递减排列，比如某个指针左右相邻key分别是i和i+1，则该指针指向节点的所有key大于等于i且小于等于i+1。  
（3）进行查找操作时，首先在根节点进行二分查找，找到一个key所在指针，然后递归地在指针所指向的节点进行查找。知道查找到叶子节点，然后在叶子节点上
进行二分查找，找出key所对应的data。  
（4）插入、删除操作会破坏树的平衡性，需要对树进行分裂、合并以及旋转来维护平衡性。  

#### 为什么选用B+树而不是B树？
主要考虑的是IO对性能的影响，B树的每个节点都存储数据，而B+树只有叶子节点才存储数据，所以查找相同数据量的情况下，B树的高度更高，IO更频繁。  
数据库索引是存储在磁盘上的，当数据量大时，就不能把整个索引全部加载到内存了，只能逐一加载每一个磁盘页（对应索引树的节点）。  
详细请见：https://mp.weixin.qq.com/s/BWlkrHiB-uP6fDnsxtKU0Q

### 3.InnoDB的索引模型
在InnoDB中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为**索引组织表**。  
每一个索引都对应一棵B+树。  

假设有一个主键列为ID的表，表中有字段k，且在字段k上建立了索引，其中有数据（100,1），（200,2），（300,3），（500,5），（600,6），则其两棵索引树的结构如下：  
![索引树](https://static001.geekbang.org/resource/image/dc/8d/dcda101051f28502bd5c4402b292e38d.png)  

**根据叶子节点内容，可把索引类型分为主键索引和非主键索引。**  
主键索引的叶子节点存储的是整行数据，在InnoDB中也叫**聚蔟索引**。  
非主键索引的叶子节点内存是主键的值。在InnoDB中，也叫做**二级索引**。  

**那么，主键索引和普通索引的查询有什么区别？**  
* 如果通过主键ID查询，直接去主键B+树就可以查到数据；  
* 如果是通过普通索引k查询，则需要先搜索k索引树，得到ID的值，再去ID主键索引树中搜索，这个过程称之为**回表**。  

**也就是说，非主键索引会多扫描一棵索引树，所以，在应用中应该尽量使用主键查询。**  

### 4.覆盖索引
如果要查询的数据只在主键索引上有，这时就避免不了回表的过程。那么，有没有可能经过索引优化，避免回表过程呢？   
加入查询语句如下：   
```
select ID from T where k between 3 and 5;
```
这时要查询的ID值已经在k索引树上了，因此可以直接提供查询结果，而不需要回表。在这个查询中，索引k已经“覆盖了”查询需求，这称为**覆盖索引**。  
**覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。**  


### 5.什么是最左前缀原则？
Mysql使用联合索引时，需要满足最左前缀原则。举例如下：  
* 一个2列的索引（name, age），对（name）、（name，age）上建立了索引。  
* 一个3列的索引（name，age，sex），对（name）、（name，age）、（name，age，sex）上建立了索引。  

（1）当B+树的数据项是符合的数据结构时，例如（name，age，sex），B+树是按照从左到右的顺序来建立搜索树的，其会优先使用name来确定下一步的所搜方向，
如果name相同再依次比较age和sex。但是如果当（22，男）这样的没有name的数据来的时候，B+树不知道第一步该查哪个节点，这样就使用不到这个索引。  
（2）当（小明，男）这样的数据来检索时，B+树可以用name来指定搜索方向，但下一个字段age的确实，所以只能把名字等于小明的数据都找到，然后再匹配性别
是男的数据了。  
（3）最左前缀匹配原则会一直向右匹配直到遇到范围查询（>,<,between,like）就停止匹配，比如a=1 and b=2 and c>3 and d=4，如果建立（a,b,c,d），则d
是用不到索引的；但如果建立（a,b,d,c），则都可以用到索引。  
（4）=和in可以乱序，比如：a=1 and b=2 and c=3建立（a,b,c）索引可以任意顺序，Mysql的优化器会优化成索引可以识别的形式。  

### 6.索引下推
在MySQL 5.6之前，查询时只能一个个回表，到主键索引上找出数据行，再对比字段值。  
在MySQL 5.6引入了索引下推优化，可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。  

如下所示：  
```
假设有联合索引(name, age)，sql语句如下：
select * from tuser where name like '张%' and age=10 and ismale=1;
```

以下为无索引下推执行流程：  
![无索引下推](https://static001.geekbang.org/resource/image/b3/ac/b32aa8b1f75611e0759e52f5915539ac.jpg)  

以下为索引下推执行流程：  
![索引下推](https://static001.geekbang.org/resource/image/76/1b/76e385f3df5a694cc4238c7b65acfe1b.jpg)  

可以看到，优化后，少了2次回表。  

### 7.怎么知道创建的索引有没有被用到？
使用Explain命令查看语句的执行计划，Mysql在执行某个语句前，会将语句过一遍查询优化器，之后得到该语句的分析，其中包含了许多信息。可以通过其中跟索引
有关的信息分析是否命中了索引。例如：possible_key、key、key_len等字段，分别说明了此语句可能使用的索引、实际使用的索引以及使用的索引长度。  

### 8.什么情况下索引会失效？查询不走索引？
#### （1）索引参与表达式计算
```
select sname from stu where age+10 = 30;
```

#### （2）函数运算
```
select sname from stu where left(date,4) < 1990；
```

#### （3）模糊查询（%%）
```
select * from manong where uname like '码农'%;  ----走索引
select * from manong where uname like %'码农'%; ----不走索引
```

#### （4）字符串与数字比较不走索引
```
create table a(a char(10));
explain select * from a where a = '1';  ----走索引
explain select * from a where a = 1;    ----不走索引，同样是使用了函数运算
```

#### （5）查询条件中有or，即使其中有字段建立了索引也不会使用；换言之，要求使用的所有字段都建立索引
```
select * from dept where a = 1 or b = 2 or c = 3;
```

#### （6）正则表达式不使用索引
#### （7）Mysql优化器会对SQL语句进行优化，若其认为全表扫描比使用索引快，则不使用索引

























