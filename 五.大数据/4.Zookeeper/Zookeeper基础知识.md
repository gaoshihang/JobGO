在分布式的多台服务器间达成数据状态的一致，是一件非常有难度和挑战的事情，因为服务器集群的软硬件故障随时会发生。  
**什么是脑裂？**
假如在HDFS中，两个应用程序都需要对一个文件路径进行写操作，但是如果两个程序对于哪台服务器是主服务器的判断不同，会分别连接到两个不同的NameNode上，并都得到了对同一个文件路径的写操作权限，这样就会引起文件数据冲突，同一个文件指向了两份不同数据。  
这种不同主服务器作出不同的响应，在分布式系统中称为“脑裂”。一旦发生脑裂，集群处于混乱状态，根本不可用。  

**怎么解决脑裂？**  
我们需要引入一个专门进行判断的服务器当“裁判”，让“裁判”决定哪台服务器是主服务器。  
Zookeeper就是这样一个裁判。  

### 一.谈谈对Zookeeper的认识
Zookeeper是一个分布式的、开源的分布式应用程序协调服务，它是一个为分布式应用提供一致性服务的软件，提供的功能包括：数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master选举、分布式锁和分布式队列等功能。
Zookeeper的目标就是封装好复杂易出错的关键服务，将简单易用的接口和性能高效、功能稳定的系统提供给用户。  

### 二.Zookeeper的功能
1.集群管理：监控节点存活状态、运行请求等；  
2.主节点选举：主节点挂了后可以从备用节点开始新一轮选举，使用Zookeeper可以协助完成这个过程；  
3.分布式锁：Zookeeper提供两种锁，独占锁和共享锁。独占锁即一次只有一个线程使用资源，共享锁是读锁共享，读写互斥，即可以有多个线程同时读同一个资源，如果
要用写锁也只能有一个线程使用。Zookeeper可以对分布式锁进行控制。  
4.命名服务：在分布式系统中，通过使用命名服务，客户端应用能够根据指定名字来获取资源或服务地址，提供者等信息。  

### 三.Paxos算法
一个提供锁服务的分布式系统，它是由多台服务器构成一个集群对外提供锁服务，应用程序连接到任意一台服务器都可以获取或者释放锁，因此这些服务器必须严格保持状态一致，不能一台服务器将锁资源交给一个应用程序，而另一台服务器将锁资源交给另一个应用程序，所以像这种分布式系统对数据一致性有更高的要求。  
Paxos算法就是用来解决这类问题的，多台服务器通过内部投票机制决定一个数据的更新与写入。Paxos基本思路见下图：  
![Paxos基本思路](https://static001.geekbang.org/resource/image/96/2f/96c6615c359f79922b9b087f6be4172f.png)  
应用程序连接到任意一台服务器后提起状态修改请求（也可以是获得某个状态锁的请求），从图上看也就是服务器1，会将这个请求发送给集群中其他服务器进行表决。如果某个服务器同时收到了另一个应用程序同样的修改请求，它可能会拒绝服务器1的表决，并且自己也发起一个同样的表决请求，那么其他服务器就会根据时间戳和服务器排序规则进行表决。  
表决结果会发送给其他所有服务器，最终发起表决的服务器也就是服务器1，会根据收到的表决结果决定该修改请求是否可以执行，从而在收到请求的时候就保证了数据的一致性。  

### 四.Zookeeper存储结构
ZooKeeper通过一种树状结构记录数据，如下图：  
![Zookeeper存储结构](https://static001.geekbang.org/resource/image/76/5f/76526be77b0026a0c3b2d661d362665f.png)  
应用程序可以通过路径的方式访问ZooKeeper中的数据，比如/services/YaView/services/stupidname这样的路径方式修改、读取数据。ZooKeeper还支持监听模式，当数据发生改变的时候，通知应用程序。  
Zookeeper中的节点称之为ZNode，其分为两种类型：  
（1）短暂/临时（Ephemeral）：当客户端和服务端断开连接后，所创建的Znode（节点）会自动删除；  
（2）持久（Persistent）：当客户端和服务端断开连接后，所创建的ZNode不会删除。  

### 五.监听器
Zookeeper能实现的功能都离不开监听器，常见的监听场景有以下两种：  
（1）监听ZNode节点的数据变化；  
（2）监听子结点的增减变化。  

### 六.Zookeeper如何实现各种功能？
来看看Zookeeper是怎么实现：统一配置管理、统一命名服务、分布式锁和集群管理的。  

#### 1.统一配置管理
假如有三个系统A、B、C，分别有三份配置，分别是A.yml,B.yml,C.yml。这三份配置非常类似，很多配置几乎一样。此时，**如果要改变其中一份的配置，可能其他两份都要改**。这时，希望把其公共的部分抽出来形成公用配置common.yml，可以把common.yml放在Zookeeper的Znode结点上，系统A、B、C监听这个结点有无变更，如果变更，即时响应。  
![统一配置管理](https://mmbiz.qpic.cn/mmbiz_jpg/2BGWl1qPxib1WCfFk2icxudIMHNPQMHIDJkMbN7WO6ITfDPHtO09zibW532otIiaLlw5vAsvtPth0FNrz4dInibPEKA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)  

#### 2.统一命名服务
统一命名服务其实跟域名一样，我们为某一部分的资源取一个名字，别人通过这个名字就可以拿到对应资源。  
如下图所示：  
![统一命名服务](https://mmbiz.qpic.cn/mmbiz_jpg/2BGWl1qPxib1WCfFk2icxudIMHNPQMHIDJDyPibE3x7OFicib01XFjibQKUygiaPTZz5F0vPkedlanemyqKCg7JVyLDlg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)  

#### 3.分布式锁（重要）
系统A、B、C都去访问/locks节点，访问的时候创建**带顺序号的临时/短暂（EPHEMERAL_SEQUENTIAL）节点**，比如，A创建了id_000000节点，B创建了id_000002节点，C创建了id_000001节点。  
![分布式锁](https://mmbiz.qpic.cn/mmbiz_jpg/2BGWl1qPxib1WCfFk2icxudIMHNPQMHIDJczzKQ6bLPE3Buwib1YJeqluPWicmZUbPadvFCU6UopDDkajKQu1FLO3A/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)  

接着，拿到/locks下的所有子结点（id_000000,id_000001,id_000002）,**判断自己创建的是不是最小的结点**。  
（1）如果是，则拿到锁。  
  释放锁：执行完操作后，把创建的节点给删除掉。  
（2）如果不是，则监听比自己要小1的节点变化。  

举个例子：  
（1）A拿到所有子结点，发现自己（id_000000）是最小的，得到锁；
（2）B发现自己（id_000002）不是最小的，所以监听比自己小1的结点id_000001的状态；  
（3）C发现自己（id_000001）不是最小的，所以监听比自己小1的结点id_000000的状态。  
（4）A执行完操作后，释放锁，删除结点id_000000，C发现其已经删除了，于是拿到锁；  
（5）B同上。  

#### 4.集群状态
系统A、B、C分别在Zookeeper中创建临时节点即可。  
![系统状态](https://mmbiz.qpic.cn/mmbiz_jpg/2BGWl1qPxib1WCfFk2icxudIMHNPQMHIDJ4lnbuRg5lEDmjlSTmdarCs8Dq7Pjg213pAq7QlXxzc7dIklkGuAWYQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)  
如果A挂了，/groupMember/A这个节点会被删除，通过监听groupMember下的子结点，B和C就能感知到A挂了（新增同理）。  

#### 5.动态选举Master
创建带顺序号的临时结点（EPHEMERAL_SEQUENTIAL），每次选取最小编号作为Master，如果Master挂了，对应结点删除，然后让新的最小编号作为Master。  


大数据系统通常是主从架构，主服务器管理集群的状态和元信息（meta-info），为了防止脑裂，运行期只能有一台主服务器，且有另一台主服务器保持热备状态保证高可用。那么应用如何才能知道当前哪个服务器是实际工作的主服务器呢？  
很多大数据系统都依赖于zookeeper，用于选举主服务器。一台主服务器启动后，会向Zookeeper注册自己，称为当前工作的主服务器，因此另一台服务器只能注册为热备服务器。如果当前主服务器宕机（在Zookeeper上记录的心跳数据不再更新），会利用Zookeeper的监听机制通知到热备服务器，热备服务器向Zookeeper注册称为当前主服务器，保证系统正常运行。  








