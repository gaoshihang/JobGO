ZAB：Zookeeper Atomic Broadcast（Zookeeper原子消息广播协议）。  
ZAB协议是作为Zookeeper数据一致性的核心算法。  

ZAB协议是为分布式协调服务Zookeeper专门设计的一种**支持崩溃恢复的原子广播协议**。  
基于该协议，Zookeeper实现了一种主备模式的系统架构来保持集群中各副本的数据一致性。Zookeeper使用一个单一的主进程来接收并处理客户端的所有事务请求，
并采用ZAB的原子广播协议，将服务器数据的状态变更以Proposal的形式广播到所有的副本进程上去。ZAB协议的这个主备模型保证了同一时刻集群中只有一个主进程来广播服务器的状态变更。  
另一方面，考虑到在分布式环境中，顺序执行的一些状态变更其前后会存在一定的依赖关系，有些状态变更必须依赖于比它早生成的那些状态变更，例如变更C需要依赖于变更A和
变更B。这样，就对ZAB提出了一个要求：**其必须能够保证一个全局的变更序列被顺序应用。**  
最后，考虑到主进程在任何时候都可能崩溃退出或重启，因此ZAB协议还需做到在当前主进程出现上述情况的时候，依然能够正常工作。  

ZAB的核心是定义了对于那些改变ZooKeeper服务器数据状态的事务请求的处理方式，如下：  
**所有事务请求由一个全局唯一的服务器来协调处理，其称为Leader服务器，而余下的其他服务器则成为Follower服务器。Leader服务器负责将客户端的事务请求转换成一个
事务Proposal（提议），并将该Proposal分发给集群中所有的Follower服务器。之后Leader服务器等待所有Follower服务器的反馈，一旦超过半数的Follower进行了正确的
反馈后，那么Leader就会再次向所有的Follower服务器分发Commit消息，要求其将前一个Proposal进行提交。**  

### 一.ZAB协议具体内容
ZAB协议包含两种基本模式：崩溃恢复和消息广播。  
当整个服务框架在启动中，或当Leader出现网络中断、崩溃退出或重启等异常情况时，ZAB协议就会进入恢复模式并选举产生新的Leader。这时，如果集群有过半的Follower与该
Leader完成了数据同步后，ZAB协议退出恢复模式，进入消息广播模式。  
当一台同样遵守ZAB协议的服务器启动后加入到集群后，如果此时集群中已经存在一个Leader，那么新加入的服务器会自动进入数据恢复模式：找到Leader所在服务器，并与其
进行数据同步，然后一起参与到消息广播流程中。**Zookeeper只允许唯一的Leader响应客户端请求，如果是Leader接收到客户端请求，会生成对应的提案并发起一轮广播协议；
如果是集群中其他服务器，则这些非Leader的服务器会将这个事务请求转发给Leader。**  

#### 1.消息广播
消息广播过程使用的是一个原子广播协议，类似于一个二阶段提交过程。  
ZAB协议抛弃了传统2PC中的中断逻辑，所有Follower服务器要么正常反馈Leader提出的事务Proposal，要么就抛弃Leader服务器。同时，只要过半的Follower反馈了响应，就可以
开始提交Proposal了，不需要等待集群所有Follower都反馈。  
在整个广播过程中，Leader会为每个Proposal分配一个全局单调递增的卫衣ID，称为事务ID（ZXID）。由于ZAB协议需要保证每个消息严格的因果关系，因此必须将每个Proposal
按照其ZXID的先后顺序来进行排序处理。  
在广播过程中，Leader会为每个Follower都分配一个单独的队列，并将Proposal依次放入，根据FIFO策略发送。每个Follower接收到Proposal后，都会首先将其以日志形式
写到本地磁盘，且在成功后反馈给Leader一个ack响应。Leader收到半数以上ack后，就广播一个Commit消息，通知所有Follower进行事务提交，同时Leader自身也完成对事务的
提交。  

#### 2.崩溃恢复
ZAB协议中，为了保证程序正常运行，整个恢复过程后需要选举出一个新的Leader，这就需要一个高效的Leader选举算法，确保快速选出新的Leader。同时，还要让集群中所有
节点都能快速感知到新的Leader。  

##### 基本特性
以下是两种会出现数据不一致的情况，以及针对这两种情况ZAB协议需要保证的特性。  
###### 特性一：ZAB需要确保已经在Leader上提交的事务最终被所有服务器提交
假设一个事务在Leader上提交了，在将commit消息发送到所有Follower之前，Leader服务器挂了。  
针对这种情况，ZAB需要确保事务Proposal最终能够在所有服务器上都被提交成功，否则将出现不一致。  

###### 特性二：ZAB需要确保丢弃那些只在Leader服务器上被提出的事务
假设初始的Leader在提出了一个事务后就崩溃推出了，导致集群中其他服务器都没有收到这个事务，于是，当该server回到集群的时候，ZAB需要确保丢弃这个事务。  

针对以上两个特性，决定了Leader算法必须确保选举出来的Leader拥有集群中所有机器最高编号（ZXID最大）的事务Proposal，这样就可以确保这个Leader一定具有所有
已经提交的提案。  

##### 数据同步
完成Leade选举后，接收客户端请求前，还需要确认事务日志中所有Proposal是否都已经被半数Follower提交了，即是否完成数据同步。  

**ZAB是如何处理需要被丢弃的Proposal的？**  
ZXID被设计为64位数字，其中低32位是一个简单的递增计数器，每生成一个Proposal，其都+1；而高32位代表Leader周期epoch的编号，每当选举产生一个新的Leader服务器，
就会从这个服务器上取出其本地日志中最大事务Proposal的ZXID，从中取出epoch，对其+1，作为新的epoch，并将Proposal置0。这种方式对于识别在Leader崩溃恢复前后
生成的Proposal非常有帮助，当一个包含了上一个Leader周期中尚未提交的Proposal的服务器启动时，其肯定无法成为Leader，因为当前集群中一定包含一个Quorum集合，该
集合中一定有机器包含更高epoch的事务Proposal。当这个旧的Leader以Follower角色连接到新Leader后，会被要求进行一个回退操作——到一个确实已被集群中半数机器提交
的最新事务Proposal。  














